# 编译器中端
![alt text](/assets/image23.png)


## 数据流分析(DFA)
定义

1. $f$: 每个块的转移函数

2. $\wedge$: 合并函数

3. 每个data flow fact的初始集合

数据流分析会产生
1. $IN[B]$和$OUT[B]$
2. 数据流分析得到的数据流事实在程序执行的所有可能路径上始终成立


### Worklist算法
算法步骤
1. 对于每一个基本块, 初始化$IN[B]$和$OUT[B]$
2. worklist为所有基本块的集合
```
while (!worklist.empty()){
    B = worklist.pop();
    IN[B] = 所有B的前驱P, OUT[P]的合并;
    OUT[B] = f(IN[B]);
    if (OUT[B] changed){
        worklist.push(所有B的后继);
    }
}
```

### 一些经典的DFA

#### Reaching Definition
一个定义 d 能到达某个程序点，当且仅当：从 d 到该程序点存在一条路径，并且在这条路径上 d 没有被“杀死”（即没有被重新赋值或覆盖）。
![alt text](/assets/image24.png)

转移函数: ```OUT[B] = GEN[B] ∪ (IN[B] - KILL[B])```
- GEN[B]: 在块B中生成的定义集合
- KILL[B]: 在块B中被覆盖(杀死)的定义集合

合并函数: ```IN[B] = ⋃ OUT[P]   // P为B的所有前驱```

是前向分析: 信息流动方向是从程序的入口向出口

#### Available Expressions
一个表达式 x + y 在某点 p 可用，当且仅当：

1. 从入口到 p 的每一条路径上都计算过 x + y，
2. 并且在到达 p 之前，x 和 y 没有被重新赋值。

![alt text](/assets/image25.png)

转移函数: ```OUT[B] = GEN[B] ∪ (IN[B] - KILL[B])```
- GEN[B]: 在块B中新计算, 且未被变量重新赋值破坏的表达式集合
- KILL[B]: 在块B被变量重新赋值破坏的表达式集合

合并函数: ```IN[B] = ⋂ OUT[P]   // P为B的所有前驱```

是前向分析

#### Live Variables
我们想知道，在程序的某个点 p，变量 x 的值是否会在从 p 出发的某条路径上被使用。

如果会被使用，那么 x 在点 p 是“活跃的”（live）

![alt text](/assets/image26.png)

转移函数: ```IN[B] = USE[B] ∪ (OUT[B] - DEF[B])```
- USE[B]: 在块B中使用但未被定义的变量集合
- DEF[B]: 在块B中被定义(赋值)的变量集合

合并函数: ```OUT[B] = ⋃ IN[S]   // S为B的所有后继```

**注意这是后向分析的, 是合并后继**


## 符号执行

是一种程序分析技术，它用符号变量（而不是具体的输入值）来模拟程序的执行过程。
1. 每个输入的变量被分配一个符号 $int\space i \rightarrow a_i$
2. 每一条程序语句根据输入的符号变量生成响应的公式
3. 每条程序路径对应一组路径约束, 路径约束描述了"什么样的输入会让程序走这一条路径"

![alt text](/assets/image27.png)

![alt text](/assets/image28.png)


### 符号执行的局限性
可扩展性: 符号执行在大程序上难以扩展, 分析速度慢, 消耗资源大, 可能原因
- 路径爆炸: 程序分支多时, 路径数呈指数增长, 导致分析难以完成
- 外部调用: 遇到库函数, 系统调用等外部代码时, 符号执行难以精确模拟其行为
- 约束求解: 路径约束复杂时, 约束求解其可能很慢或无法判断可满足性

### 符号执行的优化

#### 路径合并
解决出现分支时的路径爆炸问题

![alt text](/assets/image30.png)

#### 循环归纳
找出循环不变式: 循环结束后某个变量的值与循环次数的关系

![alt text](/assets/image31.png)

并不是总能找出循环不变式

#### 并发符号执行
Concrete(具体) + Symbolic(符号) 执行的结合

在程序运行时, 同时进行具体执行(实际输入值)和符号执行(符号变量)

可以利用具体执行发现实际路线, 同时用符号执行生成路径约束

![alt text](/assets/image32.png)


#### 推测执行
推测符号执行提供一种不用约束求解器就能猜测路径可行性的方法, 从而减少调用约束求解器的次数


## 可满足性问题

### 解路径约束
判断是否存在一组变量取值, 使所有条件都成立

通过约束求解器
- 可满足的: 一种可能借
- 不可满足
- 由于求解过程超时未知

![alt text](/assets/image29.png)

### 命题逻辑 Propositional Logic(PL)
命题逻辑的语法
1. 真值符号⊤（真，true）⊥（假，false）
2. 命题变量, 如p,q,r
3. 文字: 一个原子命题或其否定, 原子命题是真值符号或命题变量
4. 公式: 可以是：
   1. 一个文字（l）
   2. 否定：¬F
   3. 合取（与）：F₁ ∧ F₂
   4. 析取（或）：F₁ ∨ F₂
   5. 蕴含：F₁ ⇒ F₂
   6. 等价：F₁ ⟺ F₂

下列哪些是合法的命题逻辑
![alt text](/assets/image33.png)

只有4不合法, 没有and


在命题逻辑（PL）中，公式𝐹的一个解（solution）是一个映射𝐼，它把每个命题变量映射为⊤（真）或⊥（假）
- 𝐼 就是一个“赋值”或“解释”（interpretation）。
- 它为公式中的每个变量指定一个真假值。
- 如果在这个赋值下，公式𝐹为真，则𝐼是𝐹的一个解

**可满足性**: 命题逻辑中的公式F是可满足的, 当且仅当存在一个赋值I, 使得F在I下为真

**有效的(永真式)**: 命题逻辑中的公式F是有效的, 当且仅当对任意赋值I, F在I下都为真


**范式**: 在命题逻辑中指的是对公式结构的一种语法限制
- 使所有公式都能转换成某种标准结果(如合取范式, 析取范式)
- 范式有助于组织搜索空间, 简化自动判定的过程

1. 否定范式 NNF: 要求公式中不允许出现蕴含（⇒）和等价（⟺），并且否定（¬）只能直接作用于原子命题（变量），不能出现在更复杂的公式外层 

下面哪个是否定范式
![alt text](/assets/image34.png)
只有2是

2. 析取范式 DNF: 公式是若干项的析取, 每项是文字的合取

下面哪个是析取范式
![alt text](/assets/image35.png)
只有2和4是

3. 合取范式 CNF: 公式是若干子句的合取, 每个子句是文字的析取

**等可满足**: 两个公式 $F_1$ 和 $F_2$ 是等可满足的（equisatisfiable），当且仅当：
$F_1$ 可满足 $\Leftrightarrow$ $F_2$ 可满足
也就是说，只要有一个公式有解，另一个也有解；没有要求它们在所有赋值下真假完全一样(**等可满足$\not=$等价**)
- 定理: 对于命题逻辑中的任意公式$F$，都存在一个等可满足的合取范式（CNF）公式 $F'$，并且 $F'$ 的大小至多比 $F$ 大一个常数倍

### Tseitin变换
是一种将任意命题逻辑公式高效地转换为等可满足的合取范式的方法